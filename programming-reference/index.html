<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
  <!--<![endif]-->

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <title>Programming Reference - Citrix Virtual Channel SDK for Citrix Receiver for Linux 13.6</title>
     
    <link rel="shortcut icon" href="
https://www.citrix.com/etc/designs/citrix/icon-favicon.png"> 
    <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="../css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
    <link rel="stylesheet" href="../css/highlight.css">
    <link rel="stylesheet" href="../css/override.css" type="text/css" />
    <link rel="stylesheet" href="../css/font-awesome.css" type="text/css" /> 
    <script>
      // Current page data
      var mkdocs_page_name = "Programming Reference";
      var mkdocs_page_input_path = "programming-reference.md";
      var mkdocs_page_url = "/programming-reference/";

    </script>
    
    <script src="../js/jquery-2.1.1.min.js"></script>
    <script src="../js/modernizr-2.8.3.min.js"></script>
    <script type="text/javascript" src="../js/highlight.pack.js"></script>
    <script src="../js/theme.js"></script>
    <script src="../js/custom.js"></script>  
  </head>

  <body class="wy-body-for-nav" role="document">

    <div class="header-top">

        <div class="header-top-left">
          <a href="http://developer-docs.citrix.com" class="logo-position"><img height="60" src="../img/citrixlogoblack.png" target="_blank" class="logo-citrix"><span style="color:#000;font-size: 20px;position: relative;top:4px;left:20px;">Developer Documentation</span></a>
        </div>
        <div class="header-top-right">
          <ul>

            <form id="rtd-search-form-alt" class="wy-form" action="../search.html" method="get">
             <ul class="header-elements">
              <li class="list-inline support">
                <input name="q" id="txtName" type="text" placeholder="Search SDKs" class="searchdocs">
                <a class="fa fa-search errspan"></a>
<!---
              </li>
             <li> <a href="javascript:void(0);" style="font-size: 22px;position: relative;left: -10px;top: 3px"><i class="fa fa-globe"></i></a></li>
             </ul>
             --->
            </form>

          </ul>

        </div>

    </div>
    <div class="body">
      <div class="wy-grid-for-nav">

        
        <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
          <div class="wy-side-nav-search">
            <div role="search">
  <form id ="rtd-search-form-alt" class="wy-form" action="../search.html" method="get">
	<i class="fa fa-search"></i>
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
          </div>

          <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
            <ul class="current">
              
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="..">Overview</a>
		
    </li>

			  
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="../system-requirements/">System Requirements</a>
		
    </li>

			  
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="../installation/">Installing the Virtual Channel SDK</a>
		
    </li>

			  
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="../architecture/">Architecture</a>
		
    </li>

			  
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="../example-programs/">Using Example Programs</a>
		
    </li>

			  
              
    <li class="toctree-l1 ">
        <a class="toctree-l1-a " href="../programming-guide/">Programming Guide</a>
		
    </li>

			  
              
    <li class="toctree-l1 current">
        <a class="toctree-l1-a current" href="./">Programming Reference</a>
		
            <ul style="margin-left: 0px;padding-left:15px;border-left: 1px solid #b2b2b2;">
            
                <li class="toctree-l3"><a href="#programming-reference" style="padding:0px;position: relative;">&nbsp;Programming Reference</a></li>
                
                    <li><a class="toctree-l4" href="#appendvdheader-deprecated" style="padding:0px;position: relative;">AppendVdHeader (Deprecated)</a></li>
                
                    <li><a class="toctree-l4" href="#driverclose" style="padding:0px;position: relative;">DriverClose</a></li>
                
                    <li><a class="toctree-l4" href="#drivergetlasterror" style="padding:0px;position: relative;">DriverGetLastError</a></li>
                
                    <li><a class="toctree-l4" href="#driverinfo" style="padding:0px;position: relative;">DriverInfo</a></li>
                
                    <li><a class="toctree-l4" href="#driveropen" style="padding:0px;position: relative;">DriverOpen</a></li>
                
                    <li><a class="toctree-l4" href="#driverpoll" style="padding:0px;position: relative;">DriverPoll</a></li>
                
                    <li><a class="toctree-l4" href="#driverqueryinformation" style="padding:0px;position: relative;">DriverQueryInformation</a></li>
                
                    <li><a class="toctree-l4" href="#driversetinformation" style="padding:0px;position: relative;">DriverSetInformation</a></li>
                
                    <li><a class="toctree-l4" href="#evt_create" style="padding:0px;position: relative;">Evt_create</a></li>
                
                    <li><a class="toctree-l4" href="#evt_destroy" style="padding:0px;position: relative;">Evt_destroy</a></li>
                
                    <li><a class="toctree-l4" href="#evt_remove_triggers" style="padding:0px;position: relative;">Evt_remove_triggers</a></li>
                
                    <li><a class="toctree-l4" href="#evt_signal" style="padding:0px;position: relative;">Evt_signal</a></li>
                
                    <li><a class="toctree-l4" href="#evt_trigger_for_input" style="padding:0px;position: relative;">Evt_trigger_for_input</a></li>
                
                    <li><a class="toctree-l4" href="#evt_trigger_for_output" style="padding:0px;position: relative;">Evt_trigger_for_output</a></li>
                
                    <li><a class="toctree-l4" href="#icadataarrival" style="padding:0px;position: relative;">ICADataArrival</a></li>
                
                    <li><a class="toctree-l4" href="#migetprivateprofilebool" style="padding:0px;position: relative;">miGetPrivateProfileBool</a></li>
                
                    <li><a class="toctree-l4" href="#migetprivateprofileint" style="padding:0px;position: relative;">miGetPrivateProfileInt</a></li>
                
                    <li><a class="toctree-l4" href="#migetprivateprofilelong" style="padding:0px;position: relative;">miGetPrivateProfileLong</a></li>
                
                    <li><a class="toctree-l4" href="#migetprivateprofilestring" style="padding:0px;position: relative;">miGetPrivateProfileString</a></li>
                
                    <li><a class="toctree-l4" href="#mm_clip" style="padding:0px;position: relative;">MM_clip</a></li>
                
                    <li><a class="toctree-l4" href="#mm_destroy_window" style="padding:0px;position: relative;">MM_destroy_window</a></li>
                
                    <li><a class="toctree-l4" href="#mm_get_window" style="padding:0px;position: relative;">MM_get_window</a></li>
                
                    <li><a class="toctree-l4" href="#mm_set_geometry" style="padding:0px;position: relative;">MM_set_geometry</a></li>
                
                    <li><a class="toctree-l4" href="#mm_show_window" style="padding:0px;position: relative;">MM_show_window</a></li>
                
                    <li><a class="toctree-l4" href="#mm_twi_clear_new_window_function" style="padding:0px;position: relative;">MM_TWI_clear_new_window_function</a></li>
                
                    <li><a class="toctree-l4" href="#mm_twi_set_new_window_function" style="padding:0px;position: relative;">MM_TWI_set_new_window_function</a></li>
                
                    <li><a class="toctree-l4" href="#outbufappend-deprecated" style="padding:0px;position: relative;">OutBufAppend (Deprecated)</a></li>
                
                    <li><a class="toctree-l4" href="#outbufreserve-deprecated" style="padding:0px;position: relative;">OutBufReserve (Deprecated)</a></li>
                
                    <li><a class="toctree-l4" href="#outbufwrite-deprecated" style="padding:0px;position: relative;">OutBufWrite (Deprecated)</a></li>
                
                    <li><a class="toctree-l4" href="#queuevirtualwrite" style="padding:0px;position: relative;">QueueVirtualWrite</a></li>
                
                    <li><a class="toctree-l4" href="#tmr_create" style="padding:0px;position: relative;">Tmr_create</a></li>
                
                    <li><a class="toctree-l4" href="#tmr_destroy" style="padding:0px;position: relative;">Tmr_destroy</a></li>
                
                    <li><a class="toctree-l4" href="#tmr_setenabled" style="padding:0px;position: relative;">Tmr_setEnabled</a></li>
                
                    <li><a class="toctree-l4" href="#tmr_setperiod" style="padding:0px;position: relative;">Tmr_setPeriod</a></li>
                
                    <li><a class="toctree-l4" href="#vdcallwd" style="padding:0px;position: relative;">VdCallWd</a></li>
                
            
            </ul>
        
    </li>

			  
            </ul>
          </div>
          &nbsp;
        </nav>

        <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

           
          <div class="wy-nav-content">
            <div class="rst-content">
              <!-- <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Programming Reference</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div> -->
              <div role="main">
                <div class="section">
                <div class="file-format">
                 <div class="leftAlign" style="float: left;visibility: hidden;">
                  </div>
                  <div class="rightAlign" style="float: right;">
                      <span>Download full document:</span>
                      <ul class="file-types">
                        <li><a style="border: 1px solid #EE3D24;padding: 5px;font-size: 11px;color: #EE3D24;border-radius: 5px;font-weight: 700">PDF</a></li>
                        <li><a style="border: 1px solid #2A579A;padding: 5px;font-size: 11px;color: #2A579A;border-radius: 5px;font-weight: 700">DOCX</a></li>
                        <li><a style="border: 1px solid #495164;padding: 5px;font-size: 11px;color: #495164;border-radius: 5px;font-weight: 700">EMAIL</a></li>
                        <li><a style="border: 1px solid #495164;padding: 5px;font-size: 11px;color: #495164;border-radius: 5px;font-weight: 700">PRINT</a></li>
                      </ul>
                  </div>
                  </div>
                   <h1 id="programming-reference"><a class="toclink" href="#programming-reference">Programming Reference</a></h1>
<p>For function summaries, see:</p>
<ul>
<li><a href="../programming-guide/#client-side-functions-overview">Client-Side Functions Overview</a></li>
</ul>
<h2 id="appendvdheader-deprecated"><a class="toclink" href="#appendvdheader-deprecated">AppendVdHeader (Deprecated)</a></h2>
<div class="admonition tip">
<p class="admonition-title">Note<p>This function is deprecated. QueueVirtualWrite must be used in all</p>
</p>
</div>
<p>new virtual drivers.</p>
<p>Places an ICA virtual channel prefix on the output buffer prior to
assembling and sending the buffer.</p>
<h3 id="calling-convention"><a class="toclink" href="#calling-convention">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT WFCAPI AppendVdHeader (
    PWD pWd,
    USHORT Channel,
    USHORT ByteCount);
</pre></div>


<h3 id="parameters"><a class="toclink" href="#parameters">Parameters</a></h3>
<p><strong>pWD</strong></p>
<p>Pointer to a WinStation driver control structure.</p>
<p><strong>Channel</strong></p>
<p>Virtual channel number.</p>
<p><strong>ByteCount</strong></p>
<p>Actual size in bytes of the virtual channel packet data to be sent. Do
not include additional bytes reservered for the buffer overhead.</p>
<h3 id="return-values"><a class="toclink" href="#return-values">Return Values</a></h3>
<p>If the function succeeds, the return value is CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, the return value is the error code associated
with the failure; use GetLastError to get the extended error
information.</p>
<h3 id="remarks"><a class="toclink" href="#remarks">Remarks</a></h3>
<p>Call this function to prefix the virtual channel packet with the
appropriate header information. Normally the virtual driver sees only
the private packet data. However, when a virtual driver sends a virtual
channel packet to a server application, it must use this function to
prefix the data with the ICA header.</p>
<p>Use OutBufReserve to reserve a buffer prior to making this call. The
virtual driver must use this function immediately after a successful
OutBufReserve and before any other data is placed in the packet. This
action uses the additional four bytes requested in OutBufReserve, so do
not include this overhead in <em>ByteCount</em>.</p>
<p>If an ICA header or virtual channel data is appended to the buffer, the
buffer must be sent to the server before the control leaves the virtual
driver.</p>
<p>A pointer to this function is obtained from the VDWRITEHOOK structure
after hook registration in DriverOpen. The VDWRITEHOOK structure also
provides <em>pWd</em>.</p>
<h2 id="driverclose"><a class="toclink" href="#driverclose">DriverClose</a></h2>
<p>The WinStation driver calls this function prior to unloading the
virtual driver, when the ICA connection is being terminated.</p>
<h3 id="calling-convention_1"><a class="toclink" href="#calling-convention_1">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT Driverclose(
    PVD pVD,
    PDLLCLOSE pVdClose,
    PUINT16 puiSize);
</pre></div>


<h3 id="parameters_1"><a class="toclink" href="#parameters_1">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdClose</strong></p>
<p>Pointer to a standard driver close information structure.</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the driver close information structure. This is
an input parameter.</p>
<h3 id="return-values_1"><a class="toclink" href="#return-values_1">Return Values</a></h3>
<p>If the function succeeds the return value is CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, the return value is the CLIENT_ERROR_* value
corresponding to the error condition; see clterr.h (in src/inc/) for a
list of error values beginning with CLIENT_ERROR.</p>
<h3 id="remarks_1"><a class="toclink" href="#remarks_1">Remarks</a></h3>
<p>When DriverClose is called, all private driver data is freed. The
virtual driver does not need to deallocate the virtual channel or write
hooks.</p>
<p>The pVdClose structure currently contains one element – NotUsed. This
structure can be ignored.</p>
<h2 id="drivergetlasterror"><a class="toclink" href="#drivergetlasterror">DriverGetLastError</a></h2>
<p>This function is not used but is available for linking with the common
front end, VDAPI.</p>
<h3 id="calling-convention_2"><a class="toclink" href="#calling-convention_2">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverGetLastError(
    PVD pVD,
    PVDLASSTERROR pVdLastError);
</pre></div>


<h3 id="parameters_2"><a class="toclink" href="#parameters_2">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdLastError</strong></p>
<p>Pointer to a structure that receives the last error information.</p>
<h3 id="return-value"><a class="toclink" href="#return-value">Return Value</a></h3>
<p>The driver returns CLIENT_STATUS_SUCCESS.</p>
<h3 id="remarks_2"><a class="toclink" href="#remarks_2">Remarks</a></h3>
<p>This function currently has no practical significance for virtual
drivers; it is provided for compatibility with the loadable module
interface.</p>
<h2 id="driverinfo"><a class="toclink" href="#driverinfo">DriverInfo</a></h2>
<p>Gets information about the virtual driver, such as the version level of
the driver.</p>
<h3 id="calling-convention_3"><a class="toclink" href="#calling-convention_3">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverInfo(
    PVD pVD,
    PDLLINFO pVdInfo,
    PUINT16 puiSize);
</pre></div>


<h3 id="parameters_3"><a class="toclink" href="#parameters_3">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdInfo</strong></p>
<p>Pointer to a standard driver information structure.</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the driver information structure. This is an
output parameter.</p>
<h3 id="return-value_1"><a class="toclink" href="#return-value_1">Return Value</a></h3>
<p>If the function succeeds, it returns CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails because the buffer pointed to by pVdInfo is too
small, it returns CLIENT_ERROR_BUFFER_TOO_SMALL. Normally, when a
CLIENT_ERROR_* result code is returned, the ICA session is
disconnected. CLIENT_ERROR_BUFFER_ TOO_SMALL is an exception and
does not result in the ICA session being disconnected. Instead, the
WinStation driver attempts to call DriverInfo again with the ByteCount
of pVdInfo returned by the failed call.</p>
<h3 id="remarks_3"><a class="toclink" href="#remarks_3">Remarks</a></h3>
<p>When the client starts, it calls this function to retrieve
module-specific information for transmission to the host. This
information is returned to the server side of the virtual channel by
WFVirtualChannelQuery.</p>
<p>The virtual driver must support this call by returning a structure in
the pVdInfo buffer. This structure can be a developer-defined virtual
channel-specific structure, but it must begin with a VD_C2H structure,
which in turn begins with a MODULE_C2H structure. All fields of the
VD_C2H structure must be filled in except for the ChannelMask field.
See ica-c2h.h (in src/inc/) for definitions of these structures.</p>
<p>The virtual driver must first check the size of the information buffer
given against the size that the virtual driver requires (the VD_C2H
structure). The size of the input buffer is given in
pVdInfo-&gt;ByteCount.</p>
<p>If the buffer is too small to store the information that the driver
needs to send, the correct size is filled into the ByteCount field and
the driver returns CLIENT_ERROR_BUFFER_TOO_SMALL.</p>
<p>If the buffer is large enough, the driver must fill it with a
module-defined structure. At a minimum, this structure must contain a
VD_C2H structure. The VD_C2H structure must be the first data in the
buffer; additional channel-specific data can follow. All relevant fields
of this structure are filled in by this function. The flow control
method is specified in the VDFLOW structure (an element of the VD_C2H
structure). The Ping example contains a flow control selection.</p>
<p>The WinStation driver calls this function twice at initialization, after
calling DriverOpen. The first call contains a NULL information buffer
and a buffer size of zero. The driver is expected to fill in
pVdInfo-&gt;ByteCount with the required buffer size and return
CLIENT_ERROR_BUFFER_TOO_SMALL. The WinStation driver allocates a
buffer of that size and retries the operation.</p>
<p>The data buffer pointed to by pVdinfo-&gt;pBuffer must not be changed by
the virtual driver. The WinStation driver stores byte swap information
in this buffer.</p>
<p>The parameter puiSize must be initialized to the size of the driver
information structure.</p>
<h2 id="driveropen"><a class="toclink" href="#driveropen">DriverOpen</a></h2>
<p>Initializes the virtual driver. The client engine calls this
user-written function once when the client is loaded.</p>
<h3 id="calling-convention_4"><a class="toclink" href="#calling-convention_4">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverOpen(
    PVD pVD, PVDOPEN pVdOpen)
    PUINT16 puiSize);
</pre></div>


<h3 id="parameters_4"><a class="toclink" href="#parameters_4">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to the virtual driver control structure. This pointer is passed
on every call to the virtual driver.</p>
<p><strong>pVdOpen</strong></p>
<p>Pointer to the virtual driver Open structure.</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the virtual driver Open structure. This is an
output parameter.</p>
<h3 id="return-values_2"><a class="toclink" href="#return-values_2">Return Values</a></h3>
<p>If the function succeeds, it returns CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, it returns the CLIENT_ERROR_* value
corresponding to the error condition; see clterr.h (in src/inc/) for a
list of error values beginning with CLIENT_ERROR</p>
<h3 id="remarks_4"><a class="toclink" href="#remarks_4">Remarks</a></h3>
<p>The code fragments in this section are taken from the vdping example.</p>
<p>The DriverOpen function must:</p>
<p>&#49;.  Allocate a virtual channel.</p>
<p>Fill in a WDQUERYINFORMATION structure and call VdCallWd. The
WinStation driver fills in the OpenVirtualChannel structure (including
the channel number) and the data in pVd.</p>
<div class="codehilite"><pre><span></span>WDQUERYINFORMATION wdqi;
OPENVIRTUALCHANNEL OpenVirtualChannel;
UINT16 uiSize;
wdqi.WdInformationClass = WdOpenVirtualChannel;
wdqi.pWdInformation = &amp;OpenVirtualChannel;
wdqi.WdInformationLength = sizeof(OPENVIRTUALCHANNEL);
OpenVirtualChannel.pVCName = CTXPING_VIRTUAL_CHANNEL_NAME;
uiSize = sizeof(WDQUERYINFORMATION);
rc = VdCallWd(pVd, WDxQUERYINFORMATION, &amp;wdqi, &amp;uiSize);
/* do error processing here */
</pre></div>


<p>After the call to VdCallWd, the channel number is assigned in the
OpenVirtualChannel structure's Channel element. Save the channel
number and set the channel mask to indicate which channel this driver
will handle.</p>
<p>For example:</p>
<div class="codehilite"><pre><span></span>g_usVirtualChannelNum = OpenVirtualChannel.Channel;
pVdOpen-&gt;ChannelMask = (1L &lt;&lt; g_usVirtualChannelNum);
</pre></div>


<p>&#50;.  Optionally specify a pointer to a private data structure.</p>
<p>If you want the virtual driver to allocate memory for state data, it can
have a pointer to this data returned on each call by placing the pointer
in the virtual driver structure, as follows:</p>
<div class="codehilite"><pre><span></span>pVd-&gt;pPrivate = pMyStructure;
</pre></div>


<p>&#51;.  Exchange entry point data with the WinStation driver.</p>
<p>The virtual driver must register a write hook with the client WinStation
driver. The write hook is the entry point of the virtual driver to be
called when data is received for this virtual channel. The WinStation
driver returns pointers to functions that the driver must use to fill in
output buffers and sends data to the WinStation driver for transmission
to the server.</p>
<div class="codehilite"><pre><span></span>WDSETINFORMATION wdsi; VDWRITEHOOK vdwh;
// Fill in a write hook structure
vdwh.Type = g_usVirtualChannelNum; vdwh.pVdData = pVd;
vdwh.pProc = (PVDWRITEPROCEDURE) ICADataArrival;
// Fill in a set information structure
wdsi.WdInformationClass = WdVirtualWriteHook;
wdsi.pWdInformation = &amp;vdwh;
wdsi.WdInformationLength = sizeof(VDWRITEHOOK);
uiSize = sizeof(WDSETINFORMATION);
rc = VdCallWd( pVd, WDxSETINFORMATION, &amp;wdsi, &amp;uiSize);
/* do error processing here */
</pre></div>


<p>During the registration of the write hook, the WinStation driver passes
entry points for the deprecated output buffer virtual driver helper
functions to the virtual driver in the VDWRITEHOOK structure. The
DriverOpen function saves these in global variables so helper functions
in the virtual driver can use them. The WinStation driver also passes a
pointer to the WinStation driver data area, which the DriverOpen
function also saves (because it is the first argument to the virtual
driver helper functions).</p>
<div class="codehilite"><pre><span></span>// Record pointers to functions used          
// for sending data to the host.              
pWd = vdwh.pWdData;                           
pOutBufReserve = vdwh.pOutBufReserveProc;     
pOutBufAppend = vdwh.pOutBufAppenProc;        
pOutBufWrite = vdwh.pOutBufWriteProc;         
pAppendVdHeader = vdwh.pAppendVdHeaderProc;   
</pre></div>


<p>&#52;.  Allocate all memory needed by the driver and do any initialization.
    You can obtain the maximum ICA buffer size from the MaximumWriteSize
    element in the VDWRITEHOOK structure that is returned.</p>
<div class="admonition tip">
<p class="admonition-title">Note<p>vdwh.MaximumWriteSize is one byte greater than the actual</p>
</p>
</div>
<p>maximum that you can use because it also includes the channel number.</p>
<div class="codehilite"><pre><span></span>g_usMaxDataSize = vdwh.MaxiumWriteSize - 1;
if(NULL == (pMyData = malloc( g_usMaxDataSize )))
{
    return(CLIENT_ERROR_NO_MEMORY);
}
</pre></div>


<p>&#53;.  Return the size of the VDOPEN structure in <em>puiSize</em>. This is used
    by the client engine to determine the version of the virtual
    channel driver.</p>
<h2 id="driverpoll"><a class="toclink" href="#driverpoll">DriverPoll</a></h2>
<p>Allows the virtual driver to get periodic control to perform any action
as required. With the Evt_<em> and Tmr_</em> APIs, a more event driven
implementation is possible so you may find that the DriverPoll is empty.</p>
<h3 id="calling-convention_5"><a class="toclink" href="#calling-convention_5">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverPoll(
PVD pVD,
PVOID pVdPoll,
PUINT16 puiSize);
</pre></div>


<h3 id="parameters_5"><a class="toclink" href="#parameters_5">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdPoll</strong></p>
<p>Pointer to one of the driver poll information structures (DLLPOLL).</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the driver poll information structure. This is an
output parameter.</p>
<h3 id="return-values_3"><a class="toclink" href="#return-values_3">Return Values</a></h3>
<p>If the functionsucceeds, it returns CLIENT_STATUS_SUCCESS. If the driver has no data
on this polling pass, it returns CLIENT_STATUS_NO_DATA.</p>
<p>If the virtual driver cannot allocate an output buffer, it returns
CLIENT_STATUS_ERROR_RETRY so the WinStation driver does not slow
polling. The virtual driver then attempts to get an output buffer the
next time it is polled.</p>
<p>Return values that begin with CLIENT_ERROR_ are fatal errors; the ICA
session is disconnected.</p>
<h3 id="remarks_5"><a class="toclink" href="#remarks_5">Remarks</a></h3>
<p>Because the client engine is single threaded, a virtual driver is not allowed to block while waiting for a
desired result (such as the availability of an output buffer) because
this prevents the rest of the client from processing.</p>
<p>The Ping example includes examples of processing that can occur in
DriverPoll.</p>
<h2 id="driverqueryinformation"><a class="toclink" href="#driverqueryinformation">DriverQueryInformation</a></h2>
<p>Gets run-time information from the virtual driver.</p>
<h3 id="calling-convention_6"><a class="toclink" href="#calling-convention_6">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverQueryInformation(
PVD pVD,
PVDQUERYINFORMATION pVdQueryInformation,
PUINT16 puiSize);
</pre></div>


<h3 id="parameters_6"><a class="toclink" href="#parameters_6">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdQueryInformation</strong></p>
<p>Pointer to a structure that specifies the information to query and the
results buffer.</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the query information and resolves structure.
This is an output parameter.</p>
<h3 id="return-value_2"><a class="toclink" href="#return-value_2">Return Value</a></h3>
<p>The function returns CLIENT_STATUS_SUCCESS.</p>
<h3 id="remarks_6"><a class="toclink" href="#remarks_6">Remarks</a></h3>
<p>This function currently has no practical significance for virtual
drivers; it is provided for compatibility with the loadable module
interface. There are no general purpose query functions at this time
other than LastError. The LastError query is accomplished through the
DriverGetLastError function.</p>
<h2 id="driversetinformation"><a class="toclink" href="#driversetinformation">DriverSetInformation</a></h2>
<p>Sets run-time information in the virtual driver.</p>
<h3 id="calling-convention_7"><a class="toclink" href="#calling-convention_7">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT DriverSetInformation(
PVD pVD,
PVDSETINFORMATION pVdSetInformation,
PUINT16 puiSize);
</pre></div>


<h3 id="parameters_7"><a class="toclink" href="#parameters_7">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>pVdSetInformation</strong></p>
<p>Pointer to a structure that specifies the information class, a pointer
to any additional data, and the size in bytes of the additional data (if
any).</p>
<p><strong>puiSize</strong></p>
<p>Pointer to the size of the information structure. This is an input
parameter.</p>
<h3 id="return-value_3"><a class="toclink" href="#return-value_3">Return Value</a></h3>
<p>The function returns CLIENT_STATUS_SUCCESS.</p>
<h3 id="remarks_7"><a class="toclink" href="#remarks_7">Remarks</a></h3>
<p>This function can receive two information classes:</p>
<ul>
<li>
<p>VdDisableModule: When the connection is being closed.</p>
</li>
<li>
<p>VdFlush: When WFPurgeInput or WFPurgeOutput is called by the
    server-side virtual channel application. The VdSetInformation
    structure contains a pointer to a VDFLUSH structure that specifies
    which purge function was called.</p>
</li>
</ul>
<h2 id="evt_create"><a class="toclink" href="#evt_create">Evt_create</a></h2>
<p>Allocates an event structure containing a callback that can be
associated with the input or the output events of a particular file
descriptor.</p>
<h3 id="calling-convention_8"><a class="toclink" href="#calling-convention_8">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_create (
void \*hTC,
PFNDELIVER pDeliverFunc,
void \*pSubscriberId,
PEVT \*out);
</pre></div>


<h3 id="parameters_8"><a class="toclink" href="#parameters_8">Parameters</a></h3>
<p><strong>hTC</strong></p>
<p>Pass NULL value as a dummy.</p>
<p><strong>pDeliverFunc</strong></p>
<p>The callback to call.</p>
<p><strong>pSubscriberId</strong></p>
<p>Data passed as an argument to the callback.</p>
<p><strong>out</strong></p>
<p>The event structure returned.</p>
<h3 id="return-value_4"><a class="toclink" href="#return-value_4">Return Value</a></h3>
<p>The event structure created is returned with the out pointer argument.
If the function succeeds, the return value is EVT_SUCCESS.</p>
<p>If the function fails because of insufficient memory, the return value
is EVT_OBJ_CREATE_FAILED.</p>
<h3 id="remarks_8"><a class="toclink" href="#remarks_8">Remarks</a></h3>
<p>The first argument of the callback pSubscriberId is the same as the
pSubscriberId used to create the event structure.</p>
<p>The second argument nEvt is a pointer to the event structure responsible
for the callback.</p>
<h2 id="evt_destroy"><a class="toclink" href="#evt_destroy">Evt_destroy</a></h2>
<p>Destroys previously created event structure by freeing its memory and
nulling the given pointer.</p>
<h3 id="calling-convention_9"><a class="toclink" href="#calling-convention_9">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_destroy (
PEVT \*phEvt);
</pre></div>


<h3 id="parameters_9"><a class="toclink" href="#parameters_9">Parameters</a></h3>
<p><strong>phEvt</strong></p>
<p>Pointer to the event object to destroy.</p>
<h3 id="return-value_5"><a class="toclink" href="#return-value_5">Return Value</a></h3>
<p>If the function succeeds, the return value is EVT_SUCCESS.</p>
<h3 id="remarks_9"><a class="toclink" href="#remarks_9">Remarks</a></h3>
<p>The event object to destroy must be removed from the event loop using
Evt_remove_triggers, before Evt_destroy is called.</p>
<h2 id="evt_remove_triggers"><a class="toclink" href="#evt_remove_triggers">Evt_remove_triggers</a></h2>
<p>Removes the previously setup file descriptor selections from the given
file descriptor.</p>
<h3 id="calling-convention_10"><a class="toclink" href="#calling-convention_10">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_remove_triggers (
Int fd);
</pre></div>


<h3 id="parameters_10"><a class="toclink" href="#parameters_10">Parameters</a></h3>
<p><strong>fd</strong></p>
<p>The file descriptor to remove all selections from.</p>
<h3 id="return-value_6"><a class="toclink" href="#return-value_6">Return Value</a></h3>
<p>If the function succeeds, the return value is EVT_SUCCESS.</p>
<h3 id="remarks_10"><a class="toclink" href="#remarks_10">Remarks</a></h3>
<p>If both the input and output conditions are selected, both the
conditions are removed.</p>
<h2 id="evt_signal"><a class="toclink" href="#evt_signal">Evt_signal</a></h2>
<p>Calls the callback stored within the given event structure.</p>
<h3 id="calling-convention_11"><a class="toclink" href="#calling-convention_11">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_signal (
PEVT hEvt);
</pre></div>


<h3 id="parameters_11"><a class="toclink" href="#parameters_11">Parameters</a></h3>
<p><strong>hEvt</strong></p>
<p>The event structure containing the callback to call.</p>
<h3 id="return-value_7"><a class="toclink" href="#return-value_7">Return Value</a></h3>
<p>If the function succeeds, the return value is EVT_SUCCESS.</p>
<h3 id="remarks_11"><a class="toclink" href="#remarks_11">Remarks</a></h3>
<p>Calls the callback function directly. No conditions must be met prior to
this call.</p>
<h2 id="evt_trigger_for_input"><a class="toclink" href="#evt_trigger_for_input">Evt_trigger_for_input</a></h2>
<p>Connects the callback of an event structure to trigger on the given file
descriptor when it satisfies the input conditions.</p>
<h3 id="calling-convention_12"><a class="toclink" href="#calling-convention_12">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_trigger_for_input (
PEVT hEvt,
int fd);
</pre></div>


<h3 id="parameters_12"><a class="toclink" href="#parameters_12">Parameters</a></h3>
<p><strong>hEvt</strong></p>
<p>The event structure to associate with the input conditions of the given
file descriptor.</p>
<p><strong>fd</strong></p>
<p>The file descriptor.</p>
<h3 id="return-value_8"><a class="toclink" href="#return-value_8">Return Value</a></h3>
<p>If the function succeeds, the return value is EVT_SUCCESS.</p>
<p>If the function fails because of insufficient memory, the return value
is EVT_OBJ_CREATE_FAILED.</p>
<h3 id="remarks_12"><a class="toclink" href="#remarks_12">Remarks</a></h3>
<p>The Glib implementation of the event loop used by Receiver for Linux
watches for the input conditions G_IO_IN and G_IO_HUP.</p>
<h2 id="evt_trigger_for_output"><a class="toclink" href="#evt_trigger_for_output">Evt_trigger_for_output</a></h2>
<p>Connects the callback of an event structure to trigger on the given file
descriptor when it satisfies the output conditions.</p>
<h3 id="calling-convention_13"><a class="toclink" href="#calling-convention_13">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Evt_trigger_for_output (
PEVT hEvt,
int fd);
</pre></div>


<h3 id="parameters_13"><a class="toclink" href="#parameters_13">Parameters</a></h3>
<p><strong>hEvt</strong></p>
<p>The event structure to associate with the ouput conditions of the given
file descriptor.</p>
<p><strong>fd</strong></p>
<p>The file descriptor.</p>
<h3 id="return-value_9"><a class="toclink" href="#return-value_9">Return Value</a></h3>
<p>If the function succeeds, the return value is EVT_SUCCESS.</p>
<p>If the function fails because of insufficient memory, the return value
is EVT_OBJ_CREATE_FAILED.</p>
<h3 id="remarks_13"><a class="toclink" href="#remarks_13">Remarks</a></h3>
<p>The Glib implementation of the event loop used by Receiver for Linux
watches for the ouput conditions G_IO_OUT.</p>
<h2 id="icadataarrival"><a class="toclink" href="#icadataarrival">ICADataArrival</a></h2>
<p>The WinStation driver calls this function when data is received on a
virtual channel being monitored by the driver. The address of this
function is passed to the WinStation driver during DriverOpen.</p>
<h3 id="calling-convention_14"><a class="toclink" href="#calling-convention_14">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VOID wfcapi ICADataArrival(
PVD pVD,
USHORT uChan,
LPBYTE pBuf,
USHORT Length);
</pre></div>


<h3 id="parameters_14"><a class="toclink" href="#parameters_14">Parameters</a></h3>
<p><strong>pVD</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>uChan</strong></p>
<p>Virtual channel number.</p>
<p><strong>pBuf</strong></p>
<p>Pointer to the data buffer containing the virtual channel data as sent
by the server-side application.</p>
<p><strong>Length</strong></p>
<p>Length in bytes of the data in the buffer.</p>
<h3 id="return-value_10"><a class="toclink" href="#return-value_10">Return Value</a></h3>
<p>No value is returned from this function.</p>
<h3 id="remarks_14"><a class="toclink" href="#remarks_14">Remarks</a></h3>
<p>This function name is a placeholder for a user-defined function; the
actual function does not have to be called ICADataArrival, although it
does have to match the function signature (parameters and return type).
The address of this function is given to the WinStation driver during
DriverOpen. Although ICA prefixes packet control data to the virtual
channel data, this prefix is removed before this function is called.</p>
<p>After the virtual driver returns from this function, the WinStation
driver considers the data delivered. The virtual driver must save
whatever information it needs from this packet if later processing is
required.</p>
<p>Do not allow this function to block. Use your own thread or the
DriverPoll function (with polling enabled) for any required deferred
processing.</p>
<p>The virtual driver can send data to the server on receipt of this data
from within the ICADataArrival function, but be aware that the send
operation may return an immediate error when buffers are not available
to accommodate the send operation. The virtual driver may not block in
this function waiting for the sending operation to complete.</p>
<p>If the virtual driver is handling multiple virtual channels, use the
uChan parameter to determine the channel over which this data is to be
sent. See DriverOpen for more information.</p>
<h2 id="migetprivateprofilebool"><a class="toclink" href="#migetprivateprofilebool">miGetPrivateProfileBool</a></h2>
<p>Gets a Boolean value from a section of the Configuration Storage.</p>
<h3 id="calling-convention_15"><a class="toclink" href="#calling-convention_15">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT miGetPrivateProfileBool(
PCHAR lpszSection,
PCHAR lpszEntry,
BOOL bDefault);
</pre></div>


<h3 id="parameters_15"><a class="toclink" href="#parameters_15">Parameters</a></h3>
<p><strong>lpszSection</strong></p>
<p>Name of section to query.</p>
<p><strong>lpszEntry</strong></p>
<p>Name of entry to query.</p>
<p><strong>bDefault</strong></p>
<p>Default value to use.</p>
<h3 id="return-values_4"><a class="toclink" href="#return-values_4">Return Values</a></h3>
<p>If the requested entry is found, the entry value is returned; otherwise,
<em>bDefault</em> is returned.</p>
<h3 id="remarks_15"><a class="toclink" href="#remarks_15">Remarks</a></h3>
<p>A Boolean value of TRUE can be represented by on, yes, or true in the
configuration files. All other strings are interpreted as FALSE.</p>
<h2 id="migetprivateprofileint"><a class="toclink" href="#migetprivateprofileint">miGetPrivateProfileInt</a></h2>
<p>Gets an integer from a section of the Configuration Storage.</p>
<h3 id="calling-convention_16"><a class="toclink" href="#calling-convention_16">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT miGetPrivateProfileInt(
PCHAR lpszSection,
PCHAR lpszEntry,
INT iDefault);
</pre></div>


<h3 id="parameters_16"><a class="toclink" href="#parameters_16">Parameters</a></h3>
<p><strong>lpszSection</strong></p>
<p>Name of section to query.</p>
<p><strong>lpszEntry</strong></p>
<p>Name of entry to query.</p>
<p><strong>iDefault</strong></p>
<p>Default value to use.</p>
<h3 id="return-values_5"><a class="toclink" href="#return-values_5">Return Values</a></h3>
<p>If the requested entry is found, the entry value is returned; otherwise,
iDefault is returned.</p>
<h2 id="migetprivateprofilelong"><a class="toclink" href="#migetprivateprofilelong">miGetPrivateProfileLong</a></h2>
<p>Gets a long value from a section of the configuration files.</p>
<h3 id="calling-convention_17"><a class="toclink" href="#calling-convention_17">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT miGetPrivateProfileLong(
PCHAR lpszSection,
PCHAR lpszEntry,
LONG lDefault);
</pre></div>


<h3 id="parameters_17"><a class="toclink" href="#parameters_17">Parameters</a></h3>
<p><strong>lpszSection</strong></p>
<p>Name of section to query.</p>
<p><strong>lpszEntry</strong></p>
<p>Name of entry to query.</p>
<p><strong>lDefault</strong></p>
<p>Default value to use.</p>
<h3 id="return-values_6"><a class="toclink" href="#return-values_6">Return Values</a></h3>
<p>If the requested entry is found, the entry value is returned; otherwise,
lDefault is returned.</p>
<h2 id="migetprivateprofilestring"><a class="toclink" href="#migetprivateprofilestring">miGetPrivateProfileString</a></h2>
<p>Gets a string from a section of the configuration files.</p>
<h3 id="calling-convention_18"><a class="toclink" href="#calling-convention_18">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT miGetPrivateProfileString(
PCHAR lpszSection,
PCHAR lpszEntry,
PCHAR lpszDefault,
PCHAR lpszReturnBuffer, INT cbSize);
</pre></div>


<h3 id="parameters_18"><a class="toclink" href="#parameters_18">Parameters</a></h3>
<p><strong>lpszSection</strong></p>
<p>Name of section to query.</p>
<p><strong>lpszEntry</strong></p>
<p>Name of entry to query.</p>
<p><strong>lpszDefault</strong></p>
<p>Default value to use.</p>
<p><strong>lpszReturnBuffer</strong></p>
<p>Pointer to a buffer to hold results.</p>
<p><strong>cbSize</strong></p>
<p>Size of lpszReturnBuffer in bytes.</p>
<h3 id="return-values_7"><a class="toclink" href="#return-values_7">Return Values</a></h3>
<p>This function returns the string length of the value returned in
lpszReturnBuffer (not including the trailing NULL).</p>
<p>If the requested entry is found and the size of the entry string is less
than or equal to cbSize, the entry value is copied to lpszReturnBuffer;
otherwise, iDefault is copied to lpszReturnBuffer.</p>
<h3 id="remarks_16"><a class="toclink" href="#remarks_16">Remarks</a></h3>
<p>lpszDefault must fit in lpszReturnBuffer. The caller is responsible for
allocating and deallocating lpszReturnBuffer.</p>
<p>lpszReturnBuffer must be large enough to hold the maximum length entry
string, plus a NULL termination character. If an entry string does not
fit in lpszReturnBuffer, the lpszDefault value is used.</p>
<h2 id="mm_clip"><a class="toclink" href="#mm_clip">MM_clip</a></h2>
<p>Sets the shape of the operating system window “xwin” from the list of
sorted rectangles.</p>
<h3 id="calling-convention_19"><a class="toclink" href="#calling-convention_19">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>void
MM_clip (
UINT32 xwin,
int count,
struct tagTWI_RECT \*rects,
BOOLEAN extended)
</pre></div>


<h3 id="parameters_19"><a class="toclink" href="#parameters_19">Parameters</a></h3>
<p><strong>xwin</strong></p>
<p>Operating system session sub-window.</p>
<p><strong>count</strong></p>
<p>Number of rectangles.</p>
<p><strong>rects</strong></p>
<p>Array of rectangles sorted by Y and X.</p>
<p><strong>extended</strong></p>
<p>TRUE for any extensions; otherwise, FALSE.</p>
<h3 id="return-values_8"><a class="toclink" href="#return-values_8">Return Values</a></h3>
<p>There are no return values.</p>
<h3 id="remarks_17"><a class="toclink" href="#remarks_17">Remarks</a></h3>
<p>The structure has four long integers for left, top, right, and bottom.
Rectangles are YXsorted.</p>
<p>The last argument must be FALSE to start a fresh clipping update, and
TRUE to add any clipping updates to the current clipping list.</p>
<h2 id="mm_destroy_window"><a class="toclink" href="#mm_destroy_window">MM_destroy_window</a></h2>
<p>Destroys a window created by MM_get_window().</p>
<h3 id="calling-convention_20"><a class="toclink" href="#calling-convention_20">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>void
MM_destroy_window (
UINT32 hwin,
UINT32 xwin,
</pre></div>


<h3 id="parameters_20"><a class="toclink" href="#parameters_20">Parameters</a></h3>
<p><strong>hwin</strong></p>
<p>Host (seamless) window identifiers, ignored for non-seamless sessions.</p>
<p><strong>xwin</strong></p>
<p>x sub-window of the session window.</p>
<h3 id="return-values_9"><a class="toclink" href="#return-values_9">Return Values</a></h3>
<p>There are no return values.</p>
<h3 id="remarks_18"><a class="toclink" href="#remarks_18">Remarks</a></h3>
<p>MM_destroy_window also removes any window deletion callbacks added
with the low level MM_TWI_set_deletion_call.</p>
<h2 id="mm_get_window"><a class="toclink" href="#mm_get_window">MM_get_window</a></h2>
<p>Creates an operating system window "xwinp" that is a sub-window of an
existing session window with a server handle "hwin".</p>
<h3 id="calling-convention_21"><a class="toclink" href="#calling-convention_21">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>BOOLEAN
MM_get_window (
UINT32 hwin,
UINT32 \*xwinp,
</pre></div>


<h3 id="parameters_21"><a class="toclink" href="#parameters_21">Parameters</a></h3>
<p><strong>hwin</strong></p>
<p>Host (seamless) window identifiers, ignored for non-seamless sessions.</p>
<p><strong>xwinp</strong></p>
<p>Local operating system window identifier. Returns the sub-window
identifier of the session window. In this case, the X Window System is
the operating system windowing system.</p>
<h3 id="return-values_10"><a class="toclink" href="#return-values_10">Return Values</a></h3>
<p>If the parent (hwin) exists, the return value is TRUE. If the parent
does not exist, the return value is FALSE.</p>
<p>If the return value is FALSE, the function, including window creation,
still works. The root window, however, is used as a temporary parent.</p>
<p>A call to MM_get_window() or MM_set_geometry() can be used to
reparent to any existing seamless window.</p>
<h3 id="remarks_19"><a class="toclink" href="#remarks_19">Remarks</a></h3>
<p>When "0" is passed as the server handle in a non-seamless (single
window) session, there can be an existing window, *xwinp that is
reparented. The sub-window, however, is unmapped.</p>
<p>If the parent is seamless, *xwinp is protected by unmapping and
reparenting it to the root before the parent is deleted.</p>
<h2 id="mm_set_geometry"><a class="toclink" href="#mm_set_geometry">MM_set_geometry</a></h2>
<p>Sets the size and position for an existing sub-window, "xwin" of a
session window with the server handle, "hwin".</p>
<h3 id="calling-convention_22"><a class="toclink" href="#calling-convention_22">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>BOOLEAN
MM_set_geometry (
UINT32 hwin,
UINT32 xwin,
CTXMM_RECT \*rt);
</pre></div>


<h3 id="parameters_22"><a class="toclink" href="#parameters_22">Parameters</a></h3>
<p><strong>hwin</strong></p>
<p>Host (seamless) window identifiers, ignored for non-seamless sessions.</p>
<p><strong>xwin</strong></p>
<p>Local operating system window identifier for the session sub-window. In
this case, the X Window System is the operating system windowing system.</p>
<p><strong>rt</strong></p>
<p>CTXMM_RECT that describes the new window position and geometry.</p>
<h3 id="return-values_11"><a class="toclink" href="#return-values_11">Return Values</a></h3>
<p>If the parent (hwin) exists, the return value is TRUE. If the parent
does not exist, the return value is FALSE.</p>
<p>If the return value is TRUE, the sub-window is mapped on return.</p>
<h3 id="remarks_20"><a class="toclink" href="#remarks_20">Remarks</a></h3>
<p>The CTXMM_RECT window rectangle is within the session coordinates which
are not window relative and consist of four unsigned 32-bit integers for
left, top, right, and bottom.</p>
<h2 id="mm_show_window"><a class="toclink" href="#mm_show_window">MM_show_window</a></h2>
<p>Makes a sub-window visible.</p>
<h3 id="calling-convention_23"><a class="toclink" href="#calling-convention_23">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>void
MM_show_window (
UINT32 xwin)
</pre></div>


<h3 id="parameters_23"><a class="toclink" href="#parameters_23">Parameters</a></h3>
<p><strong>xwin</strong></p>
<p>Local operating system window identifier for the session sub-window. In
this case, the X Window System is the operating system windowing system.</p>
<h3 id="return-values_12"><a class="toclink" href="#return-values_12">Return Values</a></h3>
<p>There are no return values.</p>
<h3 id="remarks_21"><a class="toclink" href="#remarks_21">Remarks</a></h3>
<p>This function is called when the parent seamless window arrives after
the geometry is set.</p>
<p>There must, however, be a successful call to MM_get_window()
initially.</p>
<p>The function can be called with exactly the same window identifiers as
the previous one. It cannot be used if MM_set_geometry() previously
returned TRUE.</p>
<h2 id="mm_twi_clear_new_window_function"><a class="toclink" href="#mm_twi_clear_new_window_function">MM_TWI_clear_new_window_function</a></h2>
<p>Clears the callback function set up using
MM_TWI_set_new_window_function.</p>
<h3 id="calling-convention_24"><a class="toclink" href="#calling-convention_24">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>void
MM_TWI_clear_new_window_function (
void (\*) (UINT32))
</pre></div>


<h3 id="parameters_24"><a class="toclink" href="#parameters_24">Parameters</a></h3>
<p>(*)(UINT32))</p>
<p>Callback function pointer to remove.</p>
<h3 id="return-values_13"><a class="toclink" href="#return-values_13">Return Values</a></h3>
<p>There are no return values.</p>
<h3 id="remarks_22"><a class="toclink" href="#remarks_22">Remarks</a></h3>
<p>Clears the callback for seamless window creation.</p>
<h2 id="mm_twi_set_new_window_function"><a class="toclink" href="#mm_twi_set_new_window_function">MM_TWI_set_new_window_function</a></h2>
<p>Sets a callback function for seamless window creation.</p>
<h3 id="calling-convention_25"><a class="toclink" href="#calling-convention_25">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>void
MM_TWI_set_new_window_function (
void (*) (UINT32));
</pre></div>


<h3 id="parameters_25"><a class="toclink" href="#parameters_25">Parameters</a></h3>
<p>(*)(UINT32)</p>
<p>Callback function pointer to remove.</p>
<h3 id="return-values_14"><a class="toclink" href="#return-values_14">Return Values</a></h3>
<p>There are no return values.</p>
<h3 id="remarks_23"><a class="toclink" href="#remarks_23">Remarks</a></h3>
<p>When MM_get_window() fails because the seamless window is not yet
created, MM_TWI_set_new_window_function can be used to watch the
creation. The handle must be established only when required and should
be removed immediately. The callback argument is the server window
handle of a newly created seamless window.</p>
<h2 id="outbufappend-deprecated"><a class="toclink" href="#outbufappend-deprecated">OutBufAppend (Deprecated)</a></h2>
<div class="admonition tip">
<p class="admonition-title">Note<p>This function is deprecated. QueueVirtualWrite must be used in all</p>
</p>
</div>
<p>new virtual drivers.</p>
<p>Adds virtual channel packet data to the current output buffer.</p>
<h3 id="calling-convention_26"><a class="toclink" href="#calling-convention_26">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT WFCAPI OutBufAppend(
PWD pWd,
LPBYTE pData,
USHORT ByteCount);
</pre></div>


<h3 id="parameters_26"><a class="toclink" href="#parameters_26">Parameters</a></h3>
<p><strong>pWd</strong></p>
<p>Pointer to a WinStation driver control structure.</p>
<p><strong>pData</strong></p>
<p>Pointer to the buffer containing the data to append.</p>
<p><strong>ByteCount</strong></p>
<p>Number of bytes to append to the buffer.</p>
<h3 id="return-values_15"><a class="toclink" href="#return-values_15">Return Values</a></h3>
<p>If the function succeeds, it returns CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, it returns error code associated with the
failure; use GetLastError to get the extended error information.</p>
<h3 id="remarks_24"><a class="toclink" href="#remarks_24">Remarks</a></h3>
<p>This function adds virtual channel packet data to the end of the current
output buffer. A buffer of appropriate size must be reserved before
calling this function.</p>
<p>The address for this function is obtained from the VDWRITEHOOK structure
after hook registration. The VDWRITEHOOK structure also provides <em>pWd</em>.</p>
<p>This function can be called multiple times to build up the content of
the buffer. It is not written until OutBufWrite is called. Attempts to
write more data than was specified in OutBufReserve cause unpredictable
results.</p>
<p>The packet header information must be filled in before this function is
called.</p>
<p>If an ICA header or virtual channel data is appended to the buffer, the
buffer must be sent to the server before the control leaves the virtual
driver.</p>
<h2 id="outbufreserve-deprecated"><a class="toclink" href="#outbufreserve-deprecated">OutBufReserve (Deprecated)</a></h2>
<div class="admonition tip">
<p class="admonition-title">Note<p>This function is deprecated. QueueVirtualWrite must be used in all</p>
</p>
</div>
<p>new virtual drivers.</p>
<p>Checks if a buffer of the requested size is available. This function
does not allocate buffers because they are already allocated by the
WinStation driver.</p>
<h3 id="calling-convention_27"><a class="toclink" href="#calling-convention_27">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT WFCAPI OutBufReserve(
PWD pWd,
USHORT ByteCount);
</pre></div>


<h3 id="parameters_27"><a class="toclink" href="#parameters_27">Parameters</a></h3>
<p><strong>pWd</strong></p>
<p>Pointer to a WinStation driver control structure.</p>
<p><strong>ByteCount</strong></p>
<p>Size in bytes of the buffer needed. This must be four bytes larger than
the data to be sent.</p>
<h3 id="return-values_16"><a class="toclink" href="#return-values_16">Return Values</a></h3>
<p>If a buffer of the specified size is available, the return value is
CLIENT_STATUS_SUCCESS.</p>
<p>If a buffer of the specified size is not available, the return value is
CLIENT_ERROR_NO_OUTBUF.</p>
<h3 id="remarks_25"><a class="toclink" href="#remarks_25">Remarks</a></h3>
<p>After this function is called to reserve an output buffer, use the other
OutBuf* helper functions to append data and then send the buffer to the
server.</p>
<p>If a buffer of the specified size is not available, attempt the
operation in a later DriverPoll call.</p>
<p>The developer determines the <em>ByteCount</em>, which can be any length up to
the maximum size supported by the ICA connection. This size is
independent of size restrictions on the lower-layer transport.</p>
<ul>
<li>
<p>If the server is running XenApp or a version of Presentation Server
    3.0 Feature Release 2 or later, the maximum packet size is 5000
    bytes (4996 bytes of data plus the 4-byte packet overhead generated
    by the ICA datastream manager)</p>
</li>
<li>
<p>If the server is running a version of Presentation Server earlier
    than 3.0 Feature Release 2, the maximum packet size is 2048 bytes
    (2044 bytes of data plus the 4- byte packet overhead generated by
    the ICA datastream manager)</p>
</li>
</ul>
<p>The address for this function is obtained from the VDWRITEHOOK structure
after hook registration. The VDWRITEHOOK structure also provides the
<em>pWd</em> address.</p>
<h2 id="outbufwrite-deprecated"><a class="toclink" href="#outbufwrite-deprecated">OutBufWrite (Deprecated)</a></h2>
<div class="admonition tip">
<p class="admonition-title">Note<p>This function is deprecated. QueueVirtualWrite must be used in all</p>
</p>
</div>
<p>new virtual drivers.</p>
<p>Sends a virtual channel packet to XenApp or XenDesktop.</p>
<h3 id="calling-convention_28"><a class="toclink" href="#calling-convention_28">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT WFCAPI OutBufWrite(
PWD pWd);
</pre></div>


<h3 id="parameters_28"><a class="toclink" href="#parameters_28">Parameters</a></h3>
<p><strong>pWd</strong></p>
<p>Pointer to a WinStation driver control structure.</p>
<h3 id="return-values_17"><a class="toclink" href="#return-values_17">Return Values</a></h3>
<p>If the function succeeds, it returns CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, it returns the error code associated with the
failure; use GetLastError to get the extended error information.</p>
<h3 id="remarks_26"><a class="toclink" href="#remarks_26">Remarks</a></h3>
<p>This function sends the current output buffer to the host. If a buffer
was not reserved or no data was appended, this function does nothing.</p>
<p>If an ICA header or virtual channel data is appended to the buffer, the
buffer must be sent to the server before DriverPoll returns.</p>
<p>The address for this function is obtained from the VDWRITEHOOK structure
after hook registration. The VDWRITEHOOK structure also provides the
<em>pWd</em> address.</p>
<h2 id="queuevirtualwrite"><a class="toclink" href="#queuevirtualwrite">QueueVirtualWrite</a></h2>
<p>QueueVirtualWrite is an improved scatter gather interface. It queues a
virtual write and stimulates packet output if required allowing data to
be sent without having to wait for the poll.</p>
<h3 id="calling-convention_29"><a class="toclink" href="#calling-convention_29">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>int WFCAPI
QueueVirtualWrite (
PWD pWd,
SHORT Channel,
LPMEMORY_SECTION pMemorySections,
USHORT NrOfMemorySections,
USHORT Flag);
</pre></div>


<h3 id="parameters_29"><a class="toclink" href="#parameters_29">Parameters</a></h3>
<p><strong>pWd</strong></p>
<p>Pointer to a WinStation driver control structure.</p>
<p><strong>Channel</strong></p>
<p>The virtual channel number</p>
<p><strong>pMemorySections</strong></p>
<p>Pointer to an array memory sections.</p>
<p><strong>NrOfMemorySections</strong></p>
<p>The number of memory sections.</p>
<p><strong>Flag</strong></p>
<p>This can be FLUSH_IMMEDIATELY if the data is required to be sent
immediately or ! FLUSH_IMMEDIATELY for lower priority data.</p>
<h3 id="return-values_18"><a class="toclink" href="#return-values_18">Return Values</a></h3>
<p>If the function succeeds, that is queued successfully, the return value
is CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails because of unsuccessful queue, the return value is
CLIENT_ERROR_NO_OUTBUF.</p>
<h3 id="remarks_27"><a class="toclink" href="#remarks_27">Remarks</a></h3>
<p>The interface is simpler as it reduces the call sequence OutBufReserve,
AppendVdHeader, OutBufAppend, and OutBufWrite down to a single
QueveVirtualWrite call.</p>
<p>The data to be written across the chosen virtual channel is described by
an array of MEMORY_SECTION structures, each of which contains a length
and data pointer pair. This allows multiple non-contiguous data segments
to be combined and written with a single QueueVirtualWrite.</p>
<h2 id="tmr_create"><a class="toclink" href="#tmr_create">Tmr_create</a></h2>
<p>Creates a timer object and returns its handle.</p>
<h3 id="calling-convention_30"><a class="toclink" href="#calling-convention_30">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Tmr_create (
HND hTC,
UINT32 uiPeriod,
PVOID pvSubscriber,
PFNDELIVER pfnDeliver.
PTMR * phTimer);
</pre></div>


<h3 id="parameters_30"><a class="toclink" href="#parameters_30">Parameters</a></h3>
<p><strong>hTC</strong></p>
<p>The value is NULL.</p>
<p><strong>uiPeriod</strong></p>
<p>The timeout for the timer in milliseconds.</p>
<p><strong>pvSubscriber</strong></p>
<p>Data passed as an argument to the callback.</p>
<p><strong>pfnDeliver</strong></p>
<p>The callback to call.</p>
<p><strong>phTimer</strong></p>
<p>The returned timer structure.</p>
<h3 id="return-values_19"><a class="toclink" href="#return-values_19">Return Values</a></h3>
<p>If the function succeeds, the return value is TMR_SUCCESS.</p>
<p>If the function fails because of insufficient memory, the return value
is TMR_OBJ_CREATE_FAILED.</p>
<h3 id="remarks_28"><a class="toclink" href="#remarks_28">Remarks</a></h3>
<p>The default state of a newly created timer object is disabled. The
"deliver" function is called when the timer fires.</p>
<h2 id="tmr_destroy"><a class="toclink" href="#tmr_destroy">Tmr_destroy</a></h2>
<p>Destroys the timer object pointed to by the given handle and sets the
handle to NULL.</p>
<h3 id="calling-convention_31"><a class="toclink" href="#calling-convention_31">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Tmr_destroy (
PTMR \* phTimer);
</pre></div>


<h3 id="parameters_31"><a class="toclink" href="#parameters_31">Parameters</a></h3>
<p><strong>phTimer</strong></p>
<p>The timer to destroy.</p>
<h3 id="return-values_20"><a class="toclink" href="#return-values_20">Return Values</a></h3>
<p>If the function succeeds, the return value is TMR_SUCCESS.</p>
<h3 id="remarks_29"><a class="toclink" href="#remarks_29">Remarks</a></h3>
<p>Tmr_destroy is called for all timer objects when they are not required.</p>
<h2 id="tmr_setenabled"><a class="toclink" href="#tmr_setenabled">Tmr_setEnabled</a></h2>
<p>Enables or disables a timer object.</p>
<h3 id="calling-convention_32"><a class="toclink" href="#calling-convention_32">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Tmr_setEnabled (
PTMR \* hTimer);
BOOL fEnabled);
</pre></div>


<h3 id="parameters_32"><a class="toclink" href="#parameters_32">Parameters</a></h3>
<p><strong>hTimer</strong></p>
<p>The timer to enable or disable.</p>
<p><strong>fEnabled</strong></p>
<p>Enables or disables the timer.</p>
<h3 id="return-values_21"><a class="toclink" href="#return-values_21">Return Values</a></h3>
<p>If the function succeeds, the return value is TMR_SUCCESS.</p>
<h3 id="remarks_30"><a class="toclink" href="#remarks_30">Remarks</a></h3>
<p>Enabling a disabled timer restarts the timing period. Re-enabling an
enabled timer, however, does not perform any action.</p>
<h2 id="tmr_setperiod"><a class="toclink" href="#tmr_setperiod">Tmr_setPeriod</a></h2>
<p>Sets the timeout period for a timer.</p>
<h3 id="calling-convention_33"><a class="toclink" href="#calling-convention_33">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>VPSTATUS
Tmr_setPeriod (
PTMR \* hTimer);
UNIT32 uiPeriod);
</pre></div>


<h3 id="parameters_33"><a class="toclink" href="#parameters_33">Parameters</a></h3>
<p><strong>hTimer</strong></p>
<p>The timer to change the timeout period for.</p>
<p><strong>uiPeriod</strong></p>
<p>The new timeout period in milliseconds.</p>
<h3 id="return-values_22"><a class="toclink" href="#return-values_22">Return Values</a></h3>
<p>If the function succeeds, the return value is TMR_SUCCESS.</p>
<h3 id="remarks_31"><a class="toclink" href="#remarks_31">Remarks</a></h3>
<p>If the timer is already running, the timer is reset and fires after the
new period. If the timer is disabled, the timeout period is updated but
the timer remains disabled.</p>
<h2 id="vdcallwd"><a class="toclink" href="#vdcallwd">VdCallWd</a></h2>
<p>Calls the client WinStation driver to query and set information about
the virtual channel. This is the main method for the virtual driver to
access the WinStation driver. For general-purpose virtual channel
drivers, this sets the virtual write hook.</p>
<h3 id="calling-convention_34"><a class="toclink" href="#calling-convention_34">Calling Convention</a></h3>
<div class="codehilite"><pre><span></span>INT VdCallWd (
PVD pVd,
USHORT ProcIndex,
PVOID pParam,
PUINT16 puiSize);
</pre></div>


<h3 id="parameters_34"><a class="toclink" href="#parameters_34">Parameters</a></h3>
<p><strong>pVd</strong></p>
<p>Pointer to a virtual driver control structure.</p>
<p><strong>ProcIndex</strong></p>
<p>Index of the WinStation driver routine to call. For virtual drivers,
this can be either WDxQUERYINFORMATION or WDxSETINFORMATION.</p>
<p><strong>pParam</strong></p>
<p>Pointer to a parameter structure, used for both input and output.</p>
<p><strong>puiSize</strong></p>
<p>Size of parameter structure, used for both input and output.</p>
<h3 id="return-values_23"><a class="toclink" href="#return-values_23">Return Values</a></h3>
<p>If the function succeeds, it returns CLIENT_STATUS_SUCCESS.</p>
<p>If the function fails, it returns an error code associated with the
failure; use DriverGetLastError to get the extended error information.</p>
<h3 id="remarks_32"><a class="toclink" href="#remarks_32">Remarks</a></h3>
<p>This function is a general purpose mechanism to call routines in the
WinStation driver. The only valid uses of this function for a virtual
driver are:</p>
<ul>
<li>
<p>To allocate the virtual channel using WDxQUERYINFORMATION</p>
</li>
<li>
<p>To exchange function pointers with the WinStation driver during
    DriverOpen using WDxSETINFORMATION</p>
</li>
</ul>
<p>For more information, see DriverOpen or the Ping example.</p>
<p>On successful return, the VDWRITEHOOK structure contains pointers to the
output buffer virtual driver helper functions, and a pointer to the
WinStation driver control block (which is needed for buffer calls).</p> 

                </div>
              </div>

            </div>
          </div>

        </section>

      </div>
    </div>
    <!--<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span class="prev"><a href="../programming-guide/"><i class="fa fa-angle-left"></i> Previous</a></span>
      
      
    </span>
	<div class="footer-right">
		<ul class="social-links">
			<li class="list-inline"><a href="https://twitter.com/citrix"><i class="fa fa-twitter"></i>@citrix</a></li>
			<li class="list-inline"><a href="mailto:support@citrix.com"><i class="fa fa-envelope-o"></i>support@citrix.com</a></li>
		</ul>
		<ul class="inner-pages">
			<li class="list-inline"><a href="http://citrix.com/about/legal">Privacy and Terms</li>
		</ul>
	</div>
</div>-->

  </body>

</html>
